# 91. 解码方法（中等）
## 题目：
一条包含字母` A-Z`的消息通过以下映射进行了 **编码** ：
* 'A' -> "1"
* 'B' -> "2"
* ...
* 'Z' -> "26"

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：
* `"AAJF"` ，将消息分组为 `(1 1 10 6)`
* `"KJF"` ，将消息分组为 `(11 10 6)`

注意，消息不能分组为  `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。\
给你一个只含数字的 **非空** 字符串 s ，请计算并返回 **解码** 方法的 **总数** 。
题目数据保证答案肯定是一个 **32位** 的整数。
## 题解：
### 方法：动态规划
假设`s[1,...,i]`的所有可能性个数为`f(i)`,那么`s[1,...,i+1]`相较于`s[1,...,i]`，多了最后`s[i+1]`，那么有两种可能：
1. `s[i+1]`不为0，单独解码，则可能性个数为`f(i)*1`
2. `s[i]`不为0，`s[i]`与`s[i+1]`共同解码，则可能性个数为`f(i-1)*1`

由此可以推出状态转移方程。两种可能性累加，即为`f(i+1)`。初始化`f(0)=1`，空字符串也有一个解。
```c++
class Solution {
public:
    int numDecodings(string s) {
        int n=s.length();
        vector<int> dp(n+1);
        dp[0]=1;
        for(int i=1;i<=n;i++){
            if(s[i-1]!='0'){
                dp[i]+=dp[i-1];
            }
            if(i>1&&s[i-2]!='0'&&((s[i-2]-'0')*10+(s[i-1]-'0')<=26)){
                dp[i]+=dp[i-2];
            }
        }
        return dp[n];
    }
};
```